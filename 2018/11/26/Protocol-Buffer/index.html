<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Protobuf - An alternative approach to JSON or XML serialization in C# | Lazaro Fernandes Lima Suleiman</title><meta name="description"><meta name="generator" content="Lazaro Fernandes Lima Suleiman"><meta name="author" content="Lazaro Fernandes Lima"><meta name="keywords" content="sjaak van den berg, svdb, bitcoin, crypto, payment, integration, bitcoins, wordpress, betaling, webshop, front end, design, ontwerp, developer"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="160x160" href="/images/favicon-160x160.png"><link rel="icon" type="image/png" sizes="192x192" href="/images/favicon-192x192.png"><meta name="msapplication-TileColor" content="#121315"><meta name="msapplication-TileImage" content="/images/mstile-144x144.png"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><a href="/"><img src="/images/svdb.png" alt="Lazaro Fernandes Lima Suleiman" title="Lazaro Fernandes Lima Suleiman"></a><h1><a href="/" alt="Lazaro Fernandes Lima Suleiman" title="Lazaro Fernandes Lima Suleiman" itemprop="headline">Lazaro Fernandes Lima Suleiman</a></h1><p itemprop="description">head of technology at <a href='https://hondana.com.br'>@Hondana</a></p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/" alt="Home" title="Home" itemprop="url">Home</a></li><li itemprop="name"><a href="/articles" alt="Articles" title="Articles" itemprop="url">Articles</a></li><li itemprop="name"><a href="/about" alt="About" title="About" itemprop="url">About</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline">Protobuf - An alternative approach to JSON or XML serialization in C#</h1><span class="post-meta">Published on<time itemprop="datePublished" datetime="2018-11-26T17:53:01.000Z"> Monday, November 26th 2018 at 15:53</time><br>Last updated on<time itemprop="dateModified" datetime="2018-11-26T17:53:01.000Z"> Thursday, November 14th 2019 at 12:52</time></span><p>In a recent project at Lambda3, we developed a sync data tool in C# that uses a lot of serialization/deserialization processes.</p>
<p>Optimize those serialization/deserializations was one of the biggest challenges to increase overall performance and weve decided to use <a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">Protocol Buffers</a> or <code>protobuf</code> to handle with it.</p>
<h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><p><a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">Protobuf</a> is a protocol developed by Google to help them increase data traffic performance in an extensible and optimized way, overriding JSON and XML solutions.</p>
<h3 id="How-it-works"><a href="#How-it-works" class="headerlink" title="How it works?"></a>How it works?</h3><ul>
<li>A <code>.proto</code> file is created with a data structure definition to be used.</li>
<li>This file is compiled to generate a class that represents this structure in your application, in this case, in <code>C#</code>.</li>
<li>Instantiate the class in the application and assign the data.</li>
<li>A binary encoding is performed, using generated <code>C#</code> class methods.</li>
<li>Byte array is then trafficked to a file or a service.</li>
</ul>
<p>Let’s discuss it in more details.</p>
<p>First, a <code>.proto</code> file is created, see an example below:</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> Name = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> Id = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">string</span> Email = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">PhoneType</span> </span>&#123;</span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">PhoneNumber</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> Number = <span class="number">1</span>;</span><br><span class="line">    PhoneType Type = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">repeated</span> PhoneNumber Phone = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The structure itself is quite simple to create and understand, much like a <code>C#</code> class, it contains:</p>
<ul>
<li>data types</li>
<li>property names</li>
<li>data positioning</li>
<li>etc.</li>
</ul>
<p>For more details, see the <a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">.Proto Language Guide</a>.</p>
<p>After creating <code>.proto</code> the next step is to compile this structure to generate a file to be used by your application, in this case you’ll generate a <code>C#</code> class using <code>protoc</code>, the compiler that will read the definition and generate <code>C#</code> class.</p>
<h3 id="Where-to-download-protoc-compiler"><a href="#Where-to-download-protoc-compiler" class="headerlink" title="Where to download protoc compiler?"></a>Where to download protoc compiler?</h3><p>Until that moment, <code>3.6.1</code> is the latest stable version.</p>
<p>You can download it by many sources, these are some of them:</p>
<p><strong>dotnet global tool - <a href="https://www.nuget.org/packages/protoc" target="_blank" rel="noopener">protoc</a></strong></p>
<blockquote>
<p><code>dotnet tool install --global protoc --version 3.6.1</code></p>
</blockquote>
<p><strong>Chocolatey - <a href="https://chocolatey.org/packages/protoc" target="_blank" rel="noopener">protoc</a></strong></p>
<blockquote>
<p><code>choco install protoc --version 3.6.1</code></p>
</blockquote>
<p>If your prefer, download <code>protoc.exe</code> from oficial repository project at <a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">releases page</a>.</p>
<p>Download <code>protoc-3.6.1-win32.zip</code> file and extract <code>bin/protoc.exe</code> in a local folder, don’t forget to include <code>protoc.exe</code> path on user’s environment variables, to make it accessible by terminal, as well as installers above.</p>
<h3 id="Generating-C-classes-from-proto-files"><a href="#Generating-C-classes-from-proto-files" class="headerlink" title="Generating C# classes from .proto files"></a>Generating C# classes from .proto files</h3><p>Now, just open a terminal and run the compilation command:</p>
<blockquote>
<p><code>protoc --proto_path=&lt;protos_path&gt; --csharp_out=&lt;out_folder&gt; name.proto</code></p>
</blockquote>
<p>ex:</p>
<blockquote>
<p><code>cd c:/repos/project</code></p>
</blockquote>
<blockquote>
<p><code>protoc --proto_path=protos/ --csharp_out=Sync/Models/ Product.proto</code></p>
</blockquote>
<p>The generated file is something like <a href="https://gist.github.com/lazarofl/7bfe94f4973b2f962a00674a83575b43" target="_blank" rel="noopener">this sample at gist</a>.</p>
<p>This <code>C#</code> file can not be changed manually, only using <code>protoc</code> ;)</p>
<h3 id="How-to-use-generated-C-classes"><a href="#How-to-use-generated-C-classes" class="headerlink" title="How to use generated C# classes"></a>How to use generated C# classes</h3><p>Add the generated class on your project, it depends on <code>Google.Protobuf</code> package, so, add a referente to it on your project.</p>
<p><code>Install-Package Google.Protobuf -Version 3.6.1</code></p>
<p>The serialization process creates a byte array, using its own <a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">encoding format</a>.</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PhoneNumber and Person instances</span></span><br><span class="line"><span class="keyword">var</span> phoneNumber = <span class="keyword">new</span> <span class="type">PhoneNumber</span> &#123;</span><br><span class="line">  Number = <span class="string">"(11) 12345-6789"</span>,</span><br><span class="line">  Type = PhoneType.MOBILE;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="type">Person</span> &#123;</span><br><span class="line">  Name = <span class="string">"Lazaro"</span>;</span><br><span class="line">  Id = <span class="number">123</span>;</span><br><span class="line">  Email = <span class="string">"email@email.com"</span>;</span><br><span class="line">  Name = <span class="string">"Lazaro"</span>;</span><br><span class="line">  PhoneNumber = phoneNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//serialization process</span></span><br><span class="line">File.WriteAllBytes(<span class="string">"person123_file"</span>, person.ToByteArray());</span><br><span class="line"></span><br><span class="line"><span class="comment">//deserialization process</span></span><br><span class="line"><span class="keyword">var</span> person_fromfile = <span class="keyword">new</span> <span class="type">Person</span>();</span><br><span class="line">person_fromfile.MergeFrom(File.ReadAllBytes(<span class="string">"person123_file"</span>));</span><br></pre></td></tr></table></figure>
<p>Here is an example of how the serialization would look with the following definition.</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">message</span> = new Test1 &#123;</span><br><span class="line">  a = <span class="number">150</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">File</span>.WriteAllBytes(<span class="string">"test1"</span>, <span class="keyword">message</span>.ToByteArray());</span><br></pre></td></tr></table></figure>
<p>The <code>test1</code> file will contain only 3 bytes:</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">08 </span><span class="number">96</span> <span class="number">01</span></span><br></pre></td></tr></table></figure>
<h2 id="Why-not-use-only-XML-or-JSON"><a href="#Why-not-use-only-XML-or-JSON" class="headerlink" title="Why not use only XML or JSON?"></a>Why not use only XML or JSON?</h2><p>Both <code>XML</code> and <code>JSON</code> are excelent formats, they’re platform and language agnostics and, in most cases, easy to read and undersantand.</p>
<p>However, I listed a few points below, also taken from <a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">official documentation</a>, so you can evaluate if <code>protoc</code> fits to your case.</p>
<ul>
<li><code>.proto</code> structures are simple.</li>
<li>are 3 to 10 times smaller in size.</li>
<li>are 20 to 100 times faster</li>
<li>generated classes are easy to integrate</li>
</ul>
<p>Instead of passing strings in <code>JSON</code>, <code>XML</code> and etc., which will have a <code>Parse</code> process that can be costly in terms of processing and memory consumption, <code>protoc</code>, in turn, optimizes enconding to store only properties content, already with their pre-defined positions specified at<code>.proto</code> file, as well as other optimizations as <a href="https://carlmastrangelo.com/blog/lets-make-a-varint" target="_blank" rel="noopener"><code>128 Varints</code></a>, <a href="https://en.wikipedia.org/wiki/Signed_number_representations" target="_blank" rel="noopener">Signed Integers</a> and etc.</p>
<h2 id="JSON-and-PROTOC-comparison"><a href="#JSON-and-PROTOC-comparison" class="headerlink" title="JSON and PROTOC comparison"></a>JSON and PROTOC comparison</h2><p>I’ve created a <a href="https://github.com/lazarofl/protocvsjsoncomparison" target="_blank" rel="noopener">simple project</a> to compare <code>protoc</code> and <code>JSON</code> serialization process. You can download and run it locally.</p>
<p>The results showed that the performance of <code>protoc</code> is exponentially greater than <code>JSON</code> serialization, even though the two formats are serializing to a byte array. Look at the chart with the compiled results.</p>
<p><img src="https://github.com/lazarofl/protocvsjsoncomparison/raw/master/comparison.png" alt="protoc vs json"></p>
<p>I hope it was useful, if you have already used some implementation of <code>protobuf</code> comment on the blog.</p>
<p>See you.</p>
</article><section id="comments"><h2>Comments<div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus</a>.</noscript></div></h2></section></main><script async>(function(h,g,l,k,j,i){j=h.createElement(g),i=h.getElementsByTagName(g)[0],
j.src = '//' + l + '.disqus.com/' + k + '.js', i.parentNode.insertBefore(j, i)})
(document,'script','lazarolima','embed');
</script><script async>var disqus_shortname = 'lazarolima';
(function () {
var s = document.createElement('script'); s.async = true;
s.type = 'text/javascript';
s.src = '//' + disqus_shortname + '.disqus.com/count.js';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
}());
</script></body></html>